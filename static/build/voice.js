
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, W as globals, f as element, g as space, z as text, h as attr_dev, j as add_location, k as insert_dev, l as append_dev, A as set_data_dev, N as noop, p as detach_dev, a3 as is_function, X as validate_store, Y as component_subscribe, P as create_component, _ as src_url_equal, Q as mount_component, t as transition_in, m as group_outros, n as transition_out, o as check_outros, R as destroy_component, r as binding_callbacks } from './index-c8de33e2.js';
import { M as Menu } from './Menu-b6c2090d.js';
import { B as Button } from './Portal-ea51b76c.js';
import { S as Spinner_1 } from './Spinner-15c1d8f6.js';
import { g as generatedText, i as isLoading } from './stores-8fdee0f1.js';

/* src/components/Typewriter.svelte generated by Svelte v3.59.2 */

const { console: console_1$1 } = globals;
const file$2 = "src/components/Typewriter.svelte";

function create_fragment$2(ctx) {
	let div2;
	let div0;
	let t0;
	let h3;
	let t2;
	let div1;
	let t3;

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			h3 = element("h3");
			h3.textContent = "AIからの回答";
			t2 = space();
			div1 = element("div");
			t3 = text(/*displayedText*/ ctx[0]);
			attr_dev(div0, "class", "indicator svelte-f6lg7g");
			add_location(div0, file$2, 28, 4, 679);
			attr_dev(h3, "class", "title svelte-f6lg7g");
			add_location(h3, file$2, 29, 4, 713);
			attr_dev(div1, "class", "typewriter svelte-f6lg7g");
			add_location(div1, file$2, 30, 4, 748);
			attr_dev(div2, "class", "main svelte-f6lg7g");
			add_location(div2, file$2, 27, 0, 656);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t0);
			append_dev(div2, h3);
			append_dev(div2, t2);
			append_dev(div2, div1);
			append_dev(div1, t3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*displayedText*/ 1) set_data_dev(t3, /*displayedText*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Typewriter', slots, []);
	let { text = "" } = $$props;
	let displayedText = "";
	let interval;

	function typewrite() {
		let index = 0;

		const interval = setInterval(
			() => {
				if (index < text.length) {
					$$invalidate(0, displayedText += text[index++]);
				} else {
					clearInterval(interval);
				}

				console.log(text.length);
			},
			100
		); // 100ミリ秒ごとに文字を追加
	}

	const writable_props = ['text'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Typewriter> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('text' in $$props) $$invalidate(1, text = $$props.text);
	};

	$$self.$capture_state = () => ({ text, displayedText, interval, typewrite });

	$$self.$inject_state = $$props => {
		if ('text' in $$props) $$invalidate(1, text = $$props.text);
		if ('displayedText' in $$props) $$invalidate(0, displayedText = $$props.displayedText);
		if ('interval' in $$props) $$invalidate(2, interval = $$props.interval);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*text*/ 2) {
			// textが更新されるたびにtypewrite関数を呼び出す
			if (text) {
				$$invalidate(0, displayedText = ""); // 既存のテキストをクリア
				clearInterval(interval); // 既存のインターバルをクリア
				typewrite(); // 新しいテキストでタイプライトを開始
			}
		}
	};

	return [displayedText, text];
}

class Typewriter extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { text: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Typewriter",
			options,
			id: create_fragment$2.name
		});
	}

	get text() {
		throw new Error("<Typewriter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Typewriter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/VoiceRecognition.svelte generated by Svelte v3.59.2 */

const { console: console_1 } = globals;
const file$1 = "src/components/VoiceRecognition.svelte";

// (67:4) <Button         color={isRecording ? "danger" : "primary"}         outline={false}         on:click={isRecording ? stopRecording : startRecording}         class="custom-button"         style="display: flex; align-items: center; justify-content: center; border-radius: 50%;"     >
function create_default_slot(ctx) {
	let i;

	const block = {
		c: function create() {
			i = element("i");
			attr_dev(i, "class", "fa-solid fa-microphone");
			add_location(i, file$1, 73, 8, 2376);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(67:4) <Button         color={isRecording ? \\\"danger\\\" : \\\"primary\\\"}         outline={false}         on:click={isRecording ? stopRecording : startRecording}         class=\\\"custom-button\\\"         style=\\\"display: flex; align-items: center; justify-content: center; border-radius: 50%;\\\"     >",
		ctx
	});

	return block;
}

// (76:4) {#if isExplanationShow}
function create_if_block_1(ctx) {
	let p;

	const block = {
		c: function create() {
			p = element("p");
			p.textContent = "音声入力を開始するにはマイクアイコンをクリックしてください。";
			attr_dev(p, "class", "mt-2 font-roboto text-white svelte-1iilfaj");
			add_location(p, file$1, 76, 8, 2465);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(76:4) {#if isExplanationShow}",
		ctx
	});

	return block;
}

// (81:4) {#if isAnswerShow}
function create_if_block(ctx) {
	let typewriter;
	let current;

	typewriter = new Typewriter({
			props: { text: /*$generatedText*/ ctx[4] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(typewriter.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(typewriter, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const typewriter_changes = {};
			if (dirty & /*$generatedText*/ 16) typewriter_changes.text = /*$generatedText*/ ctx[4];
			typewriter.$set(typewriter_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(typewriter.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(typewriter.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(typewriter, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(81:4) {#if isAnswerShow}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let spinner;
	let t0;
	let div;
	let h1;
	let t2;
	let audio_1;
	let audio_1_src_value;
	let t3;
	let button;
	let t4;
	let t5;
	let current;
	spinner = new Spinner_1({ $$inline: true });

	button = new Button({
			props: {
				color: /*isRecording*/ ctx[1] ? "danger" : "primary",
				outline: false,
				class: "custom-button",
				style: "display: flex; align-items: center; justify-content: center; border-radius: 50%;",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", function () {
		if (is_function(/*isRecording*/ ctx[1]
		? /*stopRecording*/ ctx[6]
		: /*startRecording*/ ctx[5])) (/*isRecording*/ ctx[1]
		? /*stopRecording*/ ctx[6]
		: /*startRecording*/ ctx[5]).apply(this, arguments);
	});

	let if_block0 = /*isExplanationShow*/ ctx[2] && create_if_block_1(ctx);
	let if_block1 = /*isAnswerShow*/ ctx[3] && create_if_block(ctx);

	const block = {
		c: function create() {
			create_component(spinner.$$.fragment);
			t0 = space();
			div = element("div");
			h1 = element("h1");
			h1.textContent = "AIに質問をしてみましょう";
			t2 = space();
			audio_1 = element("audio");
			t3 = space();
			create_component(button.$$.fragment);
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			if (if_block1) if_block1.c();
			attr_dev(h1, "class", "text-white font-roboto text-3xl mb-4 svelte-1iilfaj");
			add_location(h1, file$1, 62, 4, 1921);
			if (!src_url_equal(audio_1.src, audio_1_src_value = "/static/sounds/voice_recognition.mp3")) attr_dev(audio_1, "src", audio_1_src_value);
			add_location(audio_1, file$1, 65, 4, 2007);
			attr_dev(div, "class", "flex svelte-1iilfaj");
			add_location(div, file$1, 61, 0, 1898);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(spinner, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, h1);
			append_dev(div, t2);
			append_dev(div, audio_1);
			/*audio_1_binding*/ ctx[7](audio_1);
			append_dev(div, t3);
			mount_component(button, div, null);
			append_dev(div, t4);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t5);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty & /*isRecording*/ 2) button_changes.color = /*isRecording*/ ctx[1] ? "danger" : "primary";

			if (dirty & /*$$scope*/ 2048) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (/*isExplanationShow*/ ctx[2]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div, t5);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*isAnswerShow*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*isAnswerShow*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(spinner.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(spinner, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			/*audio_1_binding*/ ctx[7](null);
			destroy_component(button);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $generatedText;
	validate_store(generatedText, 'generatedText');
	component_subscribe($$self, generatedText, $$value => $$invalidate(4, $generatedText = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('VoiceRecognition', slots, []);
	let audio;
	let isRecording = false;
	let mediaRecorder;
	let audioChunks = [];
	let isExplanationShow = true;
	let isAnswerShow = false;

	async function startRecording() {
		if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
			console.error("getUserMedia not supported on your browser!");
			return;
		}

		const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
		mediaRecorder = new MediaRecorder(stream);

		mediaRecorder.ondataavailable = e => {
			audioChunks.push(e.data);
		};

		mediaRecorder.onstop = sendToServer;
		mediaRecorder.start();
		$$invalidate(1, isRecording = true);
		audio.play();
	}

	function stopRecording() {
		if (!mediaRecorder) return;
		mediaRecorder.stop();
		$$invalidate(1, isRecording = false);
		mediaRecorder.stream.getTracks().forEach(track => track.stop());
		audio.play();
	}

	async function sendToServer() {
		isLoading.set(true);

		// generatedText.set("");
		const audioBlob = new Blob(audioChunks, { type: "audio/webm" });

		const formData = new FormData();
		formData.append("audio", audioBlob);
		const response = await fetch("/voice/upload", { method: "POST", body: formData });
		const result = await response.json();
		console.log("answer:", result.answer);
		audioChunks = []; // Reset chunks after sending
		isLoading.set(false);
		$$invalidate(2, isExplanationShow = false);
		$$invalidate(3, isAnswerShow = true);
		generatedText.set(result.answer);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<VoiceRecognition> was created with unknown prop '${key}'`);
	});

	function audio_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			audio = $$value;
			$$invalidate(0, audio);
		});
	}

	$$self.$capture_state = () => ({
		Button,
		Spinner: Spinner_1,
		Typewriter,
		generatedText,
		isLoading,
		audio,
		isRecording,
		mediaRecorder,
		audioChunks,
		isExplanationShow,
		isAnswerShow,
		startRecording,
		stopRecording,
		sendToServer,
		$generatedText
	});

	$$self.$inject_state = $$props => {
		if ('audio' in $$props) $$invalidate(0, audio = $$props.audio);
		if ('isRecording' in $$props) $$invalidate(1, isRecording = $$props.isRecording);
		if ('mediaRecorder' in $$props) mediaRecorder = $$props.mediaRecorder;
		if ('audioChunks' in $$props) audioChunks = $$props.audioChunks;
		if ('isExplanationShow' in $$props) $$invalidate(2, isExplanationShow = $$props.isExplanationShow);
		if ('isAnswerShow' in $$props) $$invalidate(3, isAnswerShow = $$props.isAnswerShow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		audio,
		isRecording,
		isExplanationShow,
		isAnswerShow,
		$generatedText,
		startRecording,
		stopRecording,
		audio_1_binding
	];
}

class VoiceRecognition extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VoiceRecognition",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/Voice.svelte generated by Svelte v3.59.2 */
const file = "src/Voice.svelte";

function create_fragment(ctx) {
	let div;
	let menu;
	let t;
	let voicerecognition;
	let current;
	menu = new Menu({ $$inline: true });
	voicerecognition = new VoiceRecognition({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(menu.$$.fragment);
			t = space();
			create_component(voicerecognition.$$.fragment);
			attr_dev(div, "class", "menu-area svelte-9nsflu");
			add_location(div, file, 5, 0, 142);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(menu, div, null);
			insert_dev(target, t, anchor);
			mount_component(voicerecognition, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			transition_in(voicerecognition.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menu.$$.fragment, local);
			transition_out(voicerecognition.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(menu);
			if (detaching) detach_dev(t);
			destroy_component(voicerecognition, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Voice', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Voice> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ Menu, VoiceRecognition });
	return [];
}

class Voice extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Voice",
			options,
			id: create_fragment.name
		});
	}
}

const app = new Voice({
	target: document.body,
});

export { app as default };
//# sourceMappingURL=voice.js.map
