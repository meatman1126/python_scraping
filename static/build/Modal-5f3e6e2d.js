
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, c as compute_rest_props, v as validate_slots, a1 as onMount, a as assign, e as exclude_internal_props, b as classnames, G as empty, l as insert_dev, t as transition_in, n as group_outros, o as transition_out, p as check_outros, q as detach_dev, r as bubble, g as element, C as set_attributes, a2 as toggle_class, k as add_location, D as listen_dev, E as get_spread_update, K as add_render_callback, a3 as create_in_transition, a4 as create_out_transition, f as create_slot, x as update_slot_base, y as get_all_dirty_from_scope, z as get_slot_changes, h as space, j as attr_dev, m as append_dev, A as text, B as set_data_dev, O as noop, a5 as is_function, a6 as createEventDispatcher, a7 as uuid, a8 as onDestroy, a9 as afterUpdate, aa as browserEvent, ab as conditionallyUpdateScrollbar, ac as getOriginalBodyPadding, ad as setScrollbarWidth, ae as construct_svelte_component_dev, u as binding_callbacks, Q as create_component, R as mount_component, T as destroy_component, F as run_all } from './Button-1c2619f5.js';
import { b as backdropIn, a as backdropOut, m as modalIn, c as modalOut, I as InlineContainer, P as Portal } from './Portal-b6f3c987.js';

/* node_modules/sveltestrap/src/ModalBackdrop.svelte generated by Svelte v3.59.2 */
const file$3 = "node_modules/sveltestrap/src/ModalBackdrop.svelte";

// (20:0) {#if isOpen && loaded}
function create_if_block$2(ctx) {
	let div;
	let div_intro;
	let div_outro;
	let current;
	let mounted;
	let dispose;

	let div_levels = [
		{ role: "presentation" },
		/*$$restProps*/ ctx[4],
		{ class: /*classes*/ ctx[3] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			set_attributes(div, div_data);
			toggle_class(div, "fade", /*fade*/ ctx[1]);
			add_location(div, file$3, 20, 2, 464);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler*/ ctx[6], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(div, div_data = get_spread_update(div_levels, [
				{ role: "presentation" },
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));

			toggle_class(div, "fade", /*fade*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;

			add_render_callback(() => {
				if (!current) return;
				if (div_outro) div_outro.end(1);
				div_intro = create_in_transition(div, backdropIn, {});
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, backdropOut, {});
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching && div_outro) div_outro.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(20:0) {#if isOpen && loaded}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[0] && /*loaded*/ ctx[2] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0] && /*loaded*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen, loaded*/ 5) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","isOpen","fade"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ModalBackdrop', slots, []);
	let { class: className = '' } = $$props;
	let { isOpen = false } = $$props;
	let { fade = true } = $$props;
	let loaded = false;

	onMount(() => {
		$$invalidate(2, loaded = true);
	});

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('fade' in $$new_props) $$invalidate(1, fade = $$new_props.fade);
	};

	$$self.$capture_state = () => ({
		onMount,
		classnames,
		backdropIn,
		backdropOut,
		className,
		isOpen,
		fade,
		loaded,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('fade' in $$props) $$invalidate(1, fade = $$new_props.fade);
		if ('loaded' in $$props) $$invalidate(2, loaded = $$new_props.loaded);
		if ('classes' in $$props) $$invalidate(3, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 32) {
			$$invalidate(3, classes = classnames(className, 'modal-backdrop'));
		}
	};

	return [isOpen, fade, loaded, classes, $$restProps, className, click_handler];
}

class ModalBackdrop extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { class: 5, isOpen: 0, fade: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ModalBackdrop",
			options,
			id: create_fragment$3.name
		});
	}

	get class() {
		throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fade() {
		throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fade(value) {
		throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ModalBody.svelte generated by Svelte v3.59.2 */
const file$2 = "node_modules/sveltestrap/src/ModalBody.svelte";

function create_fragment$2(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$2, 9, 0, 165);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ModalBody', slots, ['default']);
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, className, classes });

	$$self.$inject_state = $$new_props => {
		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'modal-body'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class ModalBody extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ModalBody",
			options,
			id: create_fragment$2.name
		});
	}

	get class() {
		throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/ModalHeader.svelte generated by Svelte v3.59.2 */
const file$1 = "node_modules/sveltestrap/src/ModalHeader.svelte";
const get_close_slot_changes = dirty => ({});
const get_close_slot_context = ctx => ({});

// (18:4) {:else}
function create_else_block$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(18:4) {:else}",
		ctx
	});

	return block;
}

// (16:4) {#if children}
function create_if_block_1$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*children*/ ctx[2]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*children*/ 4) set_data_dev(t, /*children*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(16:4) {#if children}",
		ctx
	});

	return block;
}

// (23:4) {#if typeof toggle === 'function'}
function create_if_block$1(ctx) {
	let button;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "btn-close");
			attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
			add_location(button, file$1, 23, 6, 522);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*toggle*/ ctx[0])) /*toggle*/ ctx[0].apply(this, arguments);
					},
					false,
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*closeAriaLabel*/ 2) {
				attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(23:4) {#if typeof toggle === 'function'}",
		ctx
	});

	return block;
}

// (22:21)      
function fallback_block(ctx) {
	let if_block_anchor;
	let if_block = typeof /*toggle*/ ctx[0] === 'function' && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (typeof /*toggle*/ ctx[0] === 'function') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(22:21)      ",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let h5;
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const close_slot_template = /*#slots*/ ctx[8].close;
	const close_slot = create_slot(close_slot_template, ctx, /*$$scope*/ ctx[7], get_close_slot_context);
	const close_slot_or_fallback = close_slot || fallback_block(ctx);
	let div_levels = [/*$$restProps*/ ctx[5], { class: /*classes*/ ctx[4] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			h5 = element("h5");
			if_block.c();
			t = space();
			if (close_slot_or_fallback) close_slot_or_fallback.c();
			attr_dev(h5, "class", "modal-title");
			attr_dev(h5, "id", /*id*/ ctx[3]);
			add_location(h5, file$1, 14, 2, 344);
			set_attributes(div, div_data);
			add_location(div, file$1, 13, 0, 303);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h5);
			if_blocks[current_block_type_index].m(h5, null);
			append_dev(div, t);

			if (close_slot_or_fallback) {
				close_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(h5, null);
			}

			if (!current || dirty & /*id*/ 8) {
				attr_dev(h5, "id", /*id*/ ctx[3]);
			}

			if (close_slot) {
				if (close_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						close_slot,
						close_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(close_slot_template, /*$$scope*/ ctx[7], dirty, get_close_slot_changes),
						get_close_slot_context
					);
				}
			} else {
				if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/ 3)) {
					close_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(close_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(close_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
			if (close_slot_or_fallback) close_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","toggle","closeAriaLabel","children","id"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ModalHeader', slots, ['default','close']);
	let { class: className = '' } = $$props;
	let { toggle = undefined } = $$props;
	let { closeAriaLabel = 'Close' } = $$props;
	let { children = undefined } = $$props;
	let { id = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('toggle' in $$new_props) $$invalidate(0, toggle = $$new_props.toggle);
		if ('closeAriaLabel' in $$new_props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
		if ('children' in $$new_props) $$invalidate(2, children = $$new_props.children);
		if ('id' in $$new_props) $$invalidate(3, id = $$new_props.id);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		className,
		toggle,
		closeAriaLabel,
		children,
		id,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ('className' in $$props) $$invalidate(6, className = $$new_props.className);
		if ('toggle' in $$props) $$invalidate(0, toggle = $$new_props.toggle);
		if ('closeAriaLabel' in $$props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
		if ('children' in $$props) $$invalidate(2, children = $$new_props.children);
		if ('id' in $$props) $$invalidate(3, id = $$new_props.id);
		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 64) {
			$$invalidate(4, classes = classnames(className, 'modal-header'));
		}
	};

	return [
		toggle,
		closeAriaLabel,
		children,
		id,
		classes,
		$$restProps,
		className,
		$$scope,
		slots
	];
}

class ModalHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			class: 6,
			toggle: 0,
			closeAriaLabel: 1,
			children: 2,
			id: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ModalHeader",
			options,
			id: create_fragment$1.name
		});
	}

	get class() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeAriaLabel() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeAriaLabel(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get children() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set children(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Modal.svelte generated by Svelte v3.59.2 */

const file = "node_modules/sveltestrap/src/Modal.svelte";
const get_external_slot_changes = dirty => ({});
const get_external_slot_context = ctx => ({});

// (223:0) {#if _isMounted}
function create_if_block_1(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*outer*/ ctx[13];

	function switch_props(ctx) {
		return {
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = {};

			if (dirty[0] & /*wrapClassName, $$restProps, labelledBy, modalClassName, fade, staticModal, classes, _dialog, contentClassName, body, toggle, header, isOpen*/ 2119615 | dirty[1] & /*$$scope*/ 8) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (dirty[0] & /*outer*/ 8192 && switch_value !== (switch_value = /*outer*/ ctx[13])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(223:0) {#if _isMounted}",
		ctx
	});

	return block;
}

// (227:6) {#if isOpen}
function create_if_block_2(ctx) {
	let div2;
	let t0;
	let div1;
	let div0;
	let t1;
	let current_block_type_index;
	let if_block1;
	let div0_class_value;
	let div2_class_value;
	let div2_intro;
	let div2_outro;
	let current;
	let mounted;
	let dispose;
	const external_slot_template = /*#slots*/ ctx[31].external;
	const external_slot = create_slot(external_slot_template, ctx, /*$$scope*/ ctx[34], get_external_slot_context);
	let if_block0 = /*header*/ ctx[3] && create_if_block_4(ctx);
	const if_block_creators = [create_if_block_3, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*body*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			if (external_slot) external_slot.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if_block1.c();
			attr_dev(div0, "class", div0_class_value = classnames('modal-content', /*contentClassName*/ ctx[9]));
			add_location(div0, file, 246, 12, 5868);
			attr_dev(div1, "class", /*classes*/ ctx[14]);
			attr_dev(div1, "role", "document");
			add_location(div1, file, 245, 10, 5798);
			attr_dev(div2, "aria-labelledby", /*labelledBy*/ ctx[5]);

			attr_dev(div2, "class", div2_class_value = classnames('modal', /*modalClassName*/ ctx[8], {
				fade: /*fade*/ ctx[10],
				'position-static': /*staticModal*/ ctx[0]
			}));

			attr_dev(div2, "role", "dialog");
			add_location(div2, file, 228, 8, 5242);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);

			if (external_slot) {
				external_slot.m(div2, null);
			}

			append_dev(div2, t0);
			append_dev(div2, div1);
			append_dev(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div0, t1);
			if_blocks[current_block_type_index].m(div0, null);
			/*div1_binding*/ ctx[32](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div2, "introstart", /*introstart_handler*/ ctx[33], false, false, false, false),
					listen_dev(div2, "introend", /*onModalOpened*/ ctx[17], false, false, false, false),
					listen_dev(div2, "outrostart", /*onModalClosing*/ ctx[18], false, false, false, false),
					listen_dev(div2, "outroend", /*onModalClosed*/ ctx[19], false, false, false, false),
					listen_dev(div2, "click", /*handleBackdropClick*/ ctx[16], false, false, false, false),
					listen_dev(div2, "mousedown", /*handleBackdropMouseDown*/ ctx[20], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (external_slot) {
				if (external_slot.p && (!current || dirty[1] & /*$$scope*/ 8)) {
					update_slot_base(
						external_slot,
						external_slot_template,
						ctx,
						/*$$scope*/ ctx[34],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[34])
						: get_slot_changes(external_slot_template, /*$$scope*/ ctx[34], dirty, get_external_slot_changes),
						get_external_slot_context
					);
				}
			}

			if (/*header*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*header*/ 8) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div0, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(div0, null);
			}

			if (!current || dirty[0] & /*contentClassName*/ 512 && div0_class_value !== (div0_class_value = classnames('modal-content', /*contentClassName*/ ctx[9]))) {
				attr_dev(div0, "class", div0_class_value);
			}

			if (!current || dirty[0] & /*classes*/ 16384) {
				attr_dev(div1, "class", /*classes*/ ctx[14]);
			}

			if (!current || dirty[0] & /*labelledBy*/ 32) {
				attr_dev(div2, "aria-labelledby", /*labelledBy*/ ctx[5]);
			}

			if (!current || dirty[0] & /*modalClassName, fade, staticModal*/ 1281 && div2_class_value !== (div2_class_value = classnames('modal', /*modalClassName*/ ctx[8], {
				fade: /*fade*/ ctx[10],
				'position-static': /*staticModal*/ ctx[0]
			}))) {
				attr_dev(div2, "class", div2_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(external_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);

			add_render_callback(() => {
				if (!current) return;
				if (div2_outro) div2_outro.end(1);
				div2_intro = create_in_transition(div2, modalIn, {});
				div2_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(external_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			if (div2_intro) div2_intro.invalidate();
			div2_outro = create_out_transition(div2, modalOut, {});
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (external_slot) external_slot.d(detaching);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			/*div1_binding*/ ctx[32](null);
			if (detaching && div2_outro) div2_outro.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(227:6) {#if isOpen}",
		ctx
	});

	return block;
}

// (248:14) {#if header}
function create_if_block_4(ctx) {
	let modalheader;
	let current;

	modalheader = new ModalHeader({
			props: {
				toggle: /*toggle*/ ctx[4],
				id: /*labelledBy*/ ctx[5],
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(modalheader.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modalheader, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modalheader_changes = {};
			if (dirty[0] & /*toggle*/ 16) modalheader_changes.toggle = /*toggle*/ ctx[4];
			if (dirty[0] & /*labelledBy*/ 32) modalheader_changes.id = /*labelledBy*/ ctx[5];

			if (dirty[0] & /*header*/ 8 | dirty[1] & /*$$scope*/ 8) {
				modalheader_changes.$$scope = { dirty, ctx };
			}

			modalheader.$set(modalheader_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modalheader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modalheader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modalheader, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(248:14) {#if header}",
		ctx
	});

	return block;
}

// (249:16) <ModalHeader {toggle} id={labelledBy}>
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*header*/ ctx[3]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*header*/ 8) set_data_dev(t, /*header*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(249:16) <ModalHeader {toggle} id={labelledBy}>",
		ctx
	});

	return block;
}

// (257:14) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[31].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[34], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[34],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[34])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[34], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(257:14) {:else}",
		ctx
	});

	return block;
}

// (253:14) {#if body}
function create_if_block_3(ctx) {
	let modalbody;
	let current;

	modalbody = new ModalBody({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(modalbody.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modalbody, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modalbody_changes = {};

			if (dirty[1] & /*$$scope*/ 8) {
				modalbody_changes.$$scope = { dirty, ctx };
			}

			modalbody.$set(modalbody_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modalbody.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modalbody.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modalbody, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(253:14) {#if body}",
		ctx
	});

	return block;
}

// (254:16) <ModalBody>
function create_default_slot_2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[31].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[34], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[34],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[34])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[34], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(254:16) <ModalBody>",
		ctx
	});

	return block;
}

// (224:2) <svelte:component this={outer}>
function create_default_slot_1(ctx) {
	let div;
	let current;
	let if_block = /*isOpen*/ ctx[1] && create_if_block_2(ctx);

	let div_levels = [
		{ class: /*wrapClassName*/ ctx[7] },
		{ tabindex: "-1" },
		/*$$restProps*/ ctx[21]
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			set_attributes(div, div_data);
			add_location(div, file, 225, 4, 5081);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*isOpen*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*isOpen*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*wrapClassName*/ 128) && { class: /*wrapClassName*/ ctx[7] },
				{ tabindex: "-1" },
				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(224:2) <svelte:component this={outer}>",
		ctx
	});

	return block;
}

// (267:0) {#if backdrop && !staticModal}
function create_if_block(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*outer*/ ctx[13];

	function switch_props(ctx) {
		return {
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = {};

			if (dirty[0] & /*fade, isOpen*/ 1026 | dirty[1] & /*$$scope*/ 8) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (dirty[0] & /*outer*/ 8192 && switch_value !== (switch_value = /*outer*/ ctx[13])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(267:0) {#if backdrop && !staticModal}",
		ctx
	});

	return block;
}

// (268:2) <svelte:component this={outer}>
function create_default_slot(ctx) {
	let modalbackdrop;
	let current;

	modalbackdrop = new ModalBackdrop({
			props: {
				fade: /*fade*/ ctx[10],
				isOpen: /*isOpen*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(modalbackdrop.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modalbackdrop, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const modalbackdrop_changes = {};
			if (dirty[0] & /*fade*/ 1024) modalbackdrop_changes.fade = /*fade*/ ctx[10];
			if (dirty[0] & /*isOpen*/ 2) modalbackdrop_changes.isOpen = /*isOpen*/ ctx[1];
			modalbackdrop.$set(modalbackdrop_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modalbackdrop.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modalbackdrop.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modalbackdrop, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(268:2) <svelte:component this={outer}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*_isMounted*/ ctx[11] && create_if_block_1(ctx);
	let if_block1 = /*backdrop*/ ctx[6] && !/*staticModal*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*_isMounted*/ ctx[11]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*_isMounted*/ 2048) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*backdrop*/ ctx[6] && !/*staticModal*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*backdrop, staticModal*/ 65) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

let openCount = 0;
const dialogBaseClass = 'modal-dialog';

function instance($$self, $$props, $$invalidate) {
	let classes;
	let outer;

	const omit_props_names = [
		"class","static","isOpen","autoFocus","body","centered","container","fullscreen","header","scrollable","size","toggle","labelledBy","backdrop","wrapClassName","modalClassName","contentClassName","fade","unmountOnClose","returnFocusAfterClose"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Modal', slots, ['external','default']);
	const dispatch = createEventDispatcher();
	let { class: className = '' } = $$props;
	let { static: staticModal = false } = $$props;
	let { isOpen = false } = $$props;
	let { autoFocus = true } = $$props;
	let { body = false } = $$props;
	let { centered = false } = $$props;
	let { container = undefined } = $$props;
	let { fullscreen = false } = $$props;
	let { header = undefined } = $$props;
	let { scrollable = false } = $$props;
	let { size = '' } = $$props;
	let { toggle = undefined } = $$props;
	let { labelledBy = header ? `modal-${uuid()}` : undefined } = $$props;
	let { backdrop = true } = $$props;
	let { wrapClassName = '' } = $$props;
	let { modalClassName = '' } = $$props;
	let { contentClassName = '' } = $$props;
	let { fade = true } = $$props;
	let { unmountOnClose = true } = $$props;
	let { returnFocusAfterClose = true } = $$props;
	let hasOpened = false;
	let _isMounted = false;
	let _triggeringElement;
	let _originalBodyPadding;
	let _lastIsOpen = isOpen;
	let _lastHasOpened = hasOpened;
	let _dialog;
	let _mouseDownElement;
	let _removeEscListener;

	onMount(() => {
		if (isOpen) {
			init();
			hasOpened = true;
		}

		if (hasOpened && autoFocus) {
			setFocus();
		}
	});

	onDestroy(() => {
		destroy();

		if (hasOpened) {
			close();
		}
	});

	afterUpdate(() => {
		if (isOpen && !_lastIsOpen) {
			init();
			hasOpened = true;
		}

		if (autoFocus && hasOpened && !_lastHasOpened) {
			setFocus();
		}

		_lastIsOpen = isOpen;
		_lastHasOpened = hasOpened;
	});

	function setFocus() {
		if (_dialog && _dialog.parentNode && typeof _dialog.parentNode.focus === 'function') {
			_dialog.parentNode.focus();
		}
	}

	function init() {
		try {
			_triggeringElement = document.activeElement;
		} catch(err) {
			_triggeringElement = null;
		}

		if (!staticModal) {
			_originalBodyPadding = getOriginalBodyPadding();
			conditionallyUpdateScrollbar();

			if (openCount === 0) {
				document.body.className = classnames(document.body.className, 'modal-open');
			}

			++openCount;
		}

		$$invalidate(11, _isMounted = true);
	}

	function manageFocusAfterClose() {
		if (_triggeringElement) {
			if (typeof _triggeringElement.focus === 'function' && returnFocusAfterClose) {
				_triggeringElement.focus();
			}

			_triggeringElement = null;
		}
	}

	function destroy() {
		manageFocusAfterClose();
	}

	function close() {
		if (openCount <= 1) {
			document.body.classList.remove('modal-open');
		}

		manageFocusAfterClose();
		openCount = Math.max(0, openCount - 1);
		setScrollbarWidth(_originalBodyPadding);
	}

	function handleBackdropClick(e) {
		if (e.target === _mouseDownElement) {
			if (!isOpen || !backdrop) {
				return;
			}

			const backdropElem = _dialog ? _dialog.parentNode : null;

			if (backdrop === true && backdropElem && e.target === backdropElem && toggle) {
				e.stopPropagation();
				toggle(e);
			}
		}
	}

	function onModalOpened() {
		dispatch('open');

		_removeEscListener = browserEvent(document, 'keydown', event => {
			if (event.key && event.key === 'Escape') {
				if (toggle && backdrop === true) {
					if (_removeEscListener) _removeEscListener();
					toggle(event);
				}
			}
		});
	}

	function onModalClosing() {
		dispatch('closing');

		if (_removeEscListener) {
			_removeEscListener();
		}
	}

	function onModalClosed() {
		dispatch('close');

		if (unmountOnClose) {
			destroy();
		}

		close();

		if (_isMounted) {
			hasOpened = false;
		}

		$$invalidate(11, _isMounted = false);
	}

	function handleBackdropMouseDown(e) {
		_mouseDownElement = e.target;
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			_dialog = $$value;
			$$invalidate(12, _dialog);
		});
	}

	const introstart_handler = () => dispatch('opening');

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(22, className = $$new_props.class);
		if ('static' in $$new_props) $$invalidate(0, staticModal = $$new_props.static);
		if ('isOpen' in $$new_props) $$invalidate(1, isOpen = $$new_props.isOpen);
		if ('autoFocus' in $$new_props) $$invalidate(23, autoFocus = $$new_props.autoFocus);
		if ('body' in $$new_props) $$invalidate(2, body = $$new_props.body);
		if ('centered' in $$new_props) $$invalidate(24, centered = $$new_props.centered);
		if ('container' in $$new_props) $$invalidate(25, container = $$new_props.container);
		if ('fullscreen' in $$new_props) $$invalidate(26, fullscreen = $$new_props.fullscreen);
		if ('header' in $$new_props) $$invalidate(3, header = $$new_props.header);
		if ('scrollable' in $$new_props) $$invalidate(27, scrollable = $$new_props.scrollable);
		if ('size' in $$new_props) $$invalidate(28, size = $$new_props.size);
		if ('toggle' in $$new_props) $$invalidate(4, toggle = $$new_props.toggle);
		if ('labelledBy' in $$new_props) $$invalidate(5, labelledBy = $$new_props.labelledBy);
		if ('backdrop' in $$new_props) $$invalidate(6, backdrop = $$new_props.backdrop);
		if ('wrapClassName' in $$new_props) $$invalidate(7, wrapClassName = $$new_props.wrapClassName);
		if ('modalClassName' in $$new_props) $$invalidate(8, modalClassName = $$new_props.modalClassName);
		if ('contentClassName' in $$new_props) $$invalidate(9, contentClassName = $$new_props.contentClassName);
		if ('fade' in $$new_props) $$invalidate(10, fade = $$new_props.fade);
		if ('unmountOnClose' in $$new_props) $$invalidate(29, unmountOnClose = $$new_props.unmountOnClose);
		if ('returnFocusAfterClose' in $$new_props) $$invalidate(30, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
		if ('$$scope' in $$new_props) $$invalidate(34, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		openCount,
		classnames,
		browserEvent,
		createEventDispatcher,
		onDestroy,
		onMount,
		afterUpdate,
		modalIn,
		modalOut,
		InlineContainer,
		ModalBackdrop,
		ModalBody,
		ModalHeader,
		Portal,
		conditionallyUpdateScrollbar,
		getOriginalBodyPadding,
		setScrollbarWidth,
		uuid,
		dispatch,
		className,
		staticModal,
		isOpen,
		autoFocus,
		body,
		centered,
		container,
		fullscreen,
		header,
		scrollable,
		size,
		toggle,
		labelledBy,
		backdrop,
		wrapClassName,
		modalClassName,
		contentClassName,
		fade,
		unmountOnClose,
		returnFocusAfterClose,
		hasOpened,
		_isMounted,
		_triggeringElement,
		_originalBodyPadding,
		_lastIsOpen,
		_lastHasOpened,
		_dialog,
		_mouseDownElement,
		_removeEscListener,
		setFocus,
		init,
		manageFocusAfterClose,
		destroy,
		close,
		handleBackdropClick,
		onModalOpened,
		onModalClosing,
		onModalClosed,
		handleBackdropMouseDown,
		dialogBaseClass,
		outer,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ('className' in $$props) $$invalidate(22, className = $$new_props.className);
		if ('staticModal' in $$props) $$invalidate(0, staticModal = $$new_props.staticModal);
		if ('isOpen' in $$props) $$invalidate(1, isOpen = $$new_props.isOpen);
		if ('autoFocus' in $$props) $$invalidate(23, autoFocus = $$new_props.autoFocus);
		if ('body' in $$props) $$invalidate(2, body = $$new_props.body);
		if ('centered' in $$props) $$invalidate(24, centered = $$new_props.centered);
		if ('container' in $$props) $$invalidate(25, container = $$new_props.container);
		if ('fullscreen' in $$props) $$invalidate(26, fullscreen = $$new_props.fullscreen);
		if ('header' in $$props) $$invalidate(3, header = $$new_props.header);
		if ('scrollable' in $$props) $$invalidate(27, scrollable = $$new_props.scrollable);
		if ('size' in $$props) $$invalidate(28, size = $$new_props.size);
		if ('toggle' in $$props) $$invalidate(4, toggle = $$new_props.toggle);
		if ('labelledBy' in $$props) $$invalidate(5, labelledBy = $$new_props.labelledBy);
		if ('backdrop' in $$props) $$invalidate(6, backdrop = $$new_props.backdrop);
		if ('wrapClassName' in $$props) $$invalidate(7, wrapClassName = $$new_props.wrapClassName);
		if ('modalClassName' in $$props) $$invalidate(8, modalClassName = $$new_props.modalClassName);
		if ('contentClassName' in $$props) $$invalidate(9, contentClassName = $$new_props.contentClassName);
		if ('fade' in $$props) $$invalidate(10, fade = $$new_props.fade);
		if ('unmountOnClose' in $$props) $$invalidate(29, unmountOnClose = $$new_props.unmountOnClose);
		if ('returnFocusAfterClose' in $$props) $$invalidate(30, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
		if ('hasOpened' in $$props) hasOpened = $$new_props.hasOpened;
		if ('_isMounted' in $$props) $$invalidate(11, _isMounted = $$new_props._isMounted);
		if ('_triggeringElement' in $$props) _triggeringElement = $$new_props._triggeringElement;
		if ('_originalBodyPadding' in $$props) _originalBodyPadding = $$new_props._originalBodyPadding;
		if ('_lastIsOpen' in $$props) _lastIsOpen = $$new_props._lastIsOpen;
		if ('_lastHasOpened' in $$props) _lastHasOpened = $$new_props._lastHasOpened;
		if ('_dialog' in $$props) $$invalidate(12, _dialog = $$new_props._dialog);
		if ('_mouseDownElement' in $$props) _mouseDownElement = $$new_props._mouseDownElement;
		if ('_removeEscListener' in $$props) _removeEscListener = $$new_props._removeEscListener;
		if ('outer' in $$props) $$invalidate(13, outer = $$new_props.outer);
		if ('classes' in $$props) $$invalidate(14, classes = $$new_props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*className, size, fullscreen, centered, scrollable*/ 490733568) {
			$$invalidate(14, classes = classnames(dialogBaseClass, className, {
				[`modal-${size}`]: size,
				'modal-fullscreen': fullscreen === true,
				[`modal-fullscreen-${fullscreen}-down`]: fullscreen && typeof fullscreen === 'string',
				[`${dialogBaseClass}-centered`]: centered,
				[`${dialogBaseClass}-scrollable`]: scrollable
			}));
		}

		if ($$self.$$.dirty[0] & /*container, staticModal*/ 33554433) {
			$$invalidate(13, outer = container === 'inline' || staticModal
			? InlineContainer
			: Portal);
		}
	};

	return [
		staticModal,
		isOpen,
		body,
		header,
		toggle,
		labelledBy,
		backdrop,
		wrapClassName,
		modalClassName,
		contentClassName,
		fade,
		_isMounted,
		_dialog,
		outer,
		classes,
		dispatch,
		handleBackdropClick,
		onModalOpened,
		onModalClosing,
		onModalClosed,
		handleBackdropMouseDown,
		$$restProps,
		className,
		autoFocus,
		centered,
		container,
		fullscreen,
		scrollable,
		size,
		unmountOnClose,
		returnFocusAfterClose,
		slots,
		div1_binding,
		introstart_handler,
		$$scope
	];
}

class Modal extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				class: 22,
				static: 0,
				isOpen: 1,
				autoFocus: 23,
				body: 2,
				centered: 24,
				container: 25,
				fullscreen: 26,
				header: 3,
				scrollable: 27,
				size: 28,
				toggle: 4,
				labelledBy: 5,
				backdrop: 6,
				wrapClassName: 7,
				modalClassName: 8,
				contentClassName: 9,
				fade: 10,
				unmountOnClose: 29,
				returnFocusAfterClose: 30
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Modal",
			options,
			id: create_fragment.name
		});
	}

	get class() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get static() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set static(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOpen() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOpen(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoFocus() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoFocus(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get body() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set body(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get centered() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set centered(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get container() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fullscreen() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fullscreen(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get header() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set header(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollable() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollable(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labelledBy() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelledBy(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrapClassName() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrapClassName(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get modalClassName() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set modalClassName(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contentClassName() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contentClassName(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fade() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fade(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get unmountOnClose() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set unmountOnClose(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get returnFocusAfterClose() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set returnFocusAfterClose(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Modal as M, ModalBody as a, ModalHeader as b };
//# sourceMappingURL=Modal-5f3e6e2d.js.map
